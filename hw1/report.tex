\documentclass{article}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{hyperref}
\usepackage{fontspec,xunicode}
\usepackage{fontenc}
\usepackage{titlesec}
\usepackage{amsmath} 
\usepackage{graphicx}
%\usepackage{nopageno}
%\usepackage{ulem}
\usepackage{xeCJK}

\setCJKmainfont{AR PL UKai TW}
\titleformat{\section}[hang]{\normalfont\LARGE\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}[hang]{\normalfont\large\bfseries}{　\thesubsection}{0.5em}{}
%\XeTeXlinebreaklocale "zh"
%\usepackage{type1cm}
\begin{document}
\fontsize{12pt}{20pt}\selectfont
\begin{center}
	\bfseries\huge{Operating System Project 1 Report}\\
\end{center}
{
    \hfill B04902012 劉瀚聲

    \hfill B04902032 馬揚格

    \hfill B04902040 王郁婷

    \hfill B04902080 徐琮賀\\
}
\section{Design}
    \subsection{Main Structure}

        For each process, it's attribute (ready time, execution time, start time and process id) is stored in a structure {\tt processData}.
        A structure {\tt processList} is constructed to maintain a list of {\tt processData}, while processes in it are sorted by ready time.

        The scheduler process {\tt S} itself is limited to run on CPU 0 with lowest nice value -20 at the beginning. Once a child process {\tt P} is forked, {\tt P} will limit itself to run on CPU 1, and it's nice value is determined by scheduling principle. After finishing setting these property, {\tt P} then execute {\tt ./child}, a process that will run million empty iterations for \(n\) times, while \(n\) is passed through {\tt argv[1]}. To make {\tt P} be able to print it's own name, it's name is passed through {\tt argv[2]}.


        To schedule, {\tt S} idles a process {\tt P1} and awake another process {\tt P2} by setting nice value of {\tt P1}  to 19 and setting nice value of {\tt P2} to -20. Child processes won't compete with {\tt S} for CPU resources because they are affined to different CPU.
    
    \subsection{FIFO}
        We construct two pointer {\tt st} and {\tt ed} pointing to processes in {\tt processList}. They both pointing the first process at the beginning. {\tt st} is maintained to point the executing process (if exists), and {\tt ed} is maintained to point the first unforked process.
        
        {\tt S} checks if the process pointed by {\tt ed} is ready every time unit. Once the child process is ready , {\tt S} forks it, and {\tt ed} moves right. {\tt S} waits non-blockingly for the process pointed by {\tt st} every time unit. Once the child process terminates, {\tt st} moves right.

        A process is awaken if: 

        (1) It is pointed by {\tt S} and has been forked.

        (2) It is forked and {\tt st} and {\tt ed} are pointing the same process.

        Actually, the processes between {\tt st+1} and {\tt ed-1} forms the ready queue.

    \subsection{Round Robin}
        We construct two pointer {\tt st} and {\tt ed} pointing to processes in {\tt processList}. They both pointing the first process at the beginning. {\tt st} is maintained to point the executing process (if exists), and {\tt ed} is maintained to point the first unforked process, just like that in FIFO.

        A counter {\tt cnt} is recorded, starting at zero. {\tt cnt} increases after each time unit. Once {\tt cnt} reaches 500, set {\tt cnt} back to zero, {\tt S} idles the currently executing process, and let {\tt st} point the next unfinished process and awake it. However, if the currently executing process terminates before {\tt cnt} reaches 500, then also set {\tt cnt} back to zero, and let {\tt st} point the next unfinished process and awake it.

    \subsection{SJF and PSJF}
        We construct a pointer {\tt ed} just like before. Also, a integer {\tt st} stores the number of terminated process. Once a process terminates, {\tt st} increases by 1.

        As long as we need to decide which process to awake, we choose the forked but unfinished process with shortest estimated remain executing time. The remain executing time of a process {\tt P} is estimated by substracting the original executing time by the real executed time.
        
\end{document}　
